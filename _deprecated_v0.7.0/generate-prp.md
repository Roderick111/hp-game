# Create PRP

## Feature file: $ARGUMENTS

Generate a complete PRP for general feature implementation with thorough research. Ensure context is passed to the AI agent to enable self-validation and iterative refinement. Read the feature file first to understand what needs to be created, how the examples provided help, and any other considerations.

The AI agent only gets the context you are appending to the PRP and training data. Assume the AI agent has access to the codebase and the same knowledge cutoff as you, so its important that your research findings are included or referenced in the PRP. The Agent has Websearch capabilities, so pass urls to documentation and examples.

Use planner subagent for this task.

## Research Process

1. **Codebase Analysis**
   - Search for similar features/patterns in the codebase
   - Identify files to reference in PRP
   - Note existing conventions to follow
   - Check test patterns for validation approach

2. **External Research**
   - Search for similar features/patterns online
   - Library documentation (include specific URLs)
   - Implementation examples (GitHub/StackOverflow/blogs)
   - Best practices and common pitfalls

3. **User Clarification** (if needed)
   - Specific patterns to mirror and where to find them?
   - Integration requirements and where to find them?

## PRP Generation

Using PRPs/templates/prp_base.md as template:

### Critical Context to Include and pass to the AI agent as part of the PRP
- **Documentation**: URLs with specific sections
- **Code Examples**: Real snippets from codebase
- **Gotchas**: Library quirks, version issues
- **Patterns**: Existing approaches to follow

### Implementation Blueprint
- Start with pseudocode showing approach
- Reference real files for patterns
- Include error handling strategy
- List tasks to be completed to fulfill the PRP in the order they should be completed

### Validation Gates (Must be Executable)
```bash
# For TypeScript/React projects:
npm run lint          # ESLint
npm run type-check    # TypeScript strict mode
npm test              # Vitest + React Testing Library
npm run build         # Vite production build
npm audit             # Security vulnerabilities

# For Python projects:
ruff check --fix && mypy .
uv run pytest tests/ -v
```

### Testing Strategy (REQUIRED)
- Define unit test files to create (>85% coverage target)
- List specific test cases for each new function/component
- Include edge cases and error scenarios
- Reference existing test patterns in codebase
- **Agent**: validation-gates will execute all tests

### Documentation Updates (REQUIRED)
After implementation, the following must be updated:
- **STATUS.md**: Mark tasks complete, update agent handoff context
- **PLANNING.md**: Update current status if milestone completes
- **README.md**: Add new features if user-facing changes
- **Serena memories**: Update project_overview if architecture changes
- **Code**: Ensure non-obvious logic is commented
- **Agent**: documentation-manager will handle these updates

*** CRITICAL AFTER YOU ARE DONE RESEARCHING AND EXPLORING THE CODEBASE BEFORE YOU START WRITING THE PRP ***

*** ULTRATHINK ABOUT THE PRP AND PLAN YOUR APPROACH THEN START WRITING THE PRP ***

## Output
Save as: `PRPs/{feature-name}.md`

## Quality Checklist
- [ ] All necessary context included
- [ ] Validation gates are executable by AI
- [ ] References existing patterns
- [ ] Clear implementation path
- [ ] Error handling documented
- [ ] Testing strategy defined with >85% coverage target
- [ ] Documentation update plan included
- [ ] Recommended next steps include validation-gates and documentation-manager agents

## Recommended Next Steps (include in PRP footer)
```yaml
Post-Implementation Workflow:
  1. Run validation-gates agent:
     - Linting, type-checking, tests, build, security
     - Fix any failures before proceeding
  2. Run documentation-manager agent:
     - Update STATUS.md, PLANNING.md, README.md
     - Update Serena memories if needed
  3. Commit changes with descriptive message
```

Score the PRP on a scale of 1-10 (confidence level to succeed in one-pass implementation using claude codes)

Remember: The goal is one-pass implementation success through comprehensive context, followed by validation and documentation.
